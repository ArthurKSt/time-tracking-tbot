"""

При запуске удалить все записи дней, устаревшие на 3месяца(условно)
Получить список пользователей
    Если по пользователю нет ни одной записи на день - удалить

Если бот пытается написать пользователю и не выходит
    -удалить день из бд


 Создавать задачу "Раз в час" с таймером удаления час+время актуальности задачи
    Если задача есть, то проверить, 
        не прерабатывает ли кто-то сейчас
            получить список работников, у которых есть на текущую дату запись День
                получить по иду дня ТочкуВремени и вытащить оттуда время работы
                    если время работы больше чем пользовательское время работы - задавать вопросы
                    
        не забыл ли кто-то выключить один из таймеров (кроме рабочего)
            получить список всех таймеров
                проверять во сколько таймер был запущен
                    если время таймера больше, чем РазрешеноНастройками - спрашивать, не забыл ли пользователь о нем
    Если задачи нет, то создать ее

 Создавать задачу "Раз в день" с таймером удаления 23часа
    Если задачи нет, то проверять время, если оно == началу рабочего дня, то создавать ее заново
    Если задача есть, то не создавать ее и не проверять время
        При создании задачи 
            проверять, все ли пришли вовремя
            создать задачу удалить все старые записи



"""

"""
Типы задач: (task_text, for_who)
    По пользователям
        0:whyNotAtWork 1:+:{telegram_id}
    Системные
        1:deleteMessage -:=:message_id
        1:checkStartWork -:=:*
        "1:everyDay_task"
"""

"""
Приоритет настроек:
    сначала гостевые (для всех работают, даже не обязательно вступать в гостевую группу)

    потом идут по весу группы.
        Если вес одной группы выше другой, то ее правило перебивает первую
            Пример: Если гоствая группа дала allow на добавление кнопки start, а рабочая группа дала deny, то добавления кнопки старт не будет

    потом идут права человека (перебивают любой вес)
        Если у человека установлен другой график, не как у группы, то будет использоваться его график

Пользовательские/групповые параметры
    Права на нажатия BtnM_ - меню, Btn - в клавиатуре
        allow/deny (Аллоу разрешает, дени запрещает))

    Права функциональные Perk_
        типо _can_see_payment - может видеть зарплату
        или _bot_ignore - бот не сможет ему написать

    Права конфиги - Conf_
        Conf_work_days настройка рабочих дней, (какие дни недели рабочие, а какие - нет) - (0,0,0,0,0,0) - нет рабочих дней (7 нулей)
        Conf_work_start настройка начала рабочего дня (во сколько начинается рабочий день) - Строка "ЧЧ:ММ" или "-" если игнорировать
        Conf_work_lenght Настройка длины рабочего времени (сколько времени оно длится) - сколько часов
        Conf_need_echo настройка нужно ли отмечать присутствие раз в рабочий день (1)- да
        Conf_no_overheat настройка, нужно ли спрашивать о переработках
        Conf_keep_work_timer  нужно ли проверять, не забыл ли человек выключить рабочий таймер
        Conf_keep_free_timer  нужно ли проверять, не забыл ли человек выключить таймер перерывов
        Conf_keep_other_timer  Нужно ли проверять, не забыл ли человек выключить Любой таймер
        


"""
from creators.c_scheduled_create import scheduled
from database.bd_tasks_activity import delete_Old_tasks, delete_task_byId, select_task_byType_list, select_task_taskText
from database.bd_user_group_activity import select_userId_list_round, delete_guests, delete_user
from database.bd_get_perms import bd_getUser_perm_list
from database.bd_user_time_activity import delete_older_Day, select_days_list_byUser
from handlers.latecomers import late_needAsk
from h_functions.delete_message_per_time import do_delete



def user_checkTask_init():
    #1) Проверяем всех работников
    bd_workers = select_userId_list_round(2, 999) # [(uniq_id),..]
    # print("___DO TASK, wrkers: ", bd_workers)
    if bd_workers: #Если есть хотя бы один работник
        for worker_id in bd_workers:

            if not select_days_list_byUser( worker_id ): 
                delete_user( worker_id )
                print("Удален потому что нет инфомации о нем")
                continue


            # print("work id: ",worker_id)

            worker_perms = bd_getUser_perm_list(worker_id[0]) #Key: [parm, weight]
            # print("work perms: ", worker_perms)

            try:
                workdays = worker_perms["Conf_work_days"]
            except: continue # Если не получилось получить информацию о рабочих днях
            else:
                curpos = scheduled.getWeekDayPosition()
                print(curpos)
                print(workdays)
                if workdays[0][curpos] == "0": continue #Если это не рабочий день
                else: #Если текущий день - рабочий (только тогда нужно ставить новые задачи)
                
                # Настройка времени начала работы
                    try: #Пытаемся получить время начала работы
                        workstarttime = worker_perms["Conf_work_start"]
                    except: pass # Если не получилось ничего не делаем
                    else:
                        #Создаем задачу, проверять, пришел ли человек вовремя
                        scheduled.create_CheckTask_startInTime(worker_id, workstarttime[0])

                
                # Настройка нужно ли спрашивать ежедневно "работал ли ты?"
                    try: #Пытаемся получить время начала работы
                        needEcho = worker_perms["Conf_need_echo"]
                    except: pass # Если не получилось ничего не делаем
                    else:
                        if needEcho[0] == 1:
                            #Создаем задачу, проверять, пришел ли человек вовремя
                            scheduled.create_CheckTask_startInTime(worker_id)

                
                # Настройка нужно ли спрашивать о переработке
                    try: #Пытаемся получить нужно ли проверять это
                        noOverheat = worker_perms["Conf_no_overheat"]
                    except: pass # Если не получилось ничего не делаем
                    else:
                        if noOverheat[0] == 1: 
                            scheduled.create_CheckTask_noOverheat(worker_id)

                
                # Настройка нужно ли спрашивать о переработке
                    try: #Пытаемся получить нужно ли проверять это
                        noFogetCloseWork = worker_perms["Conf_keep_work_timer"]
                    except: pass # Если не получилось ничего не делаем
                    else:
                        if noFogetCloseWork[0] == 1: #Создаем задачу
                            scheduled.create_CheckTask_noFogetClose(worker_id, "work")

                
                # Настройка нужно ли спрашивать о переработке
                    try: #Пытаемся получить нужно ли проверять это
                        noFogetCloseFree = worker_perms["Conf_keep_free_timer"]
                    except: pass # Если не получилось ничего не делаем
                    else:
                        if noFogetCloseFree[0] == 1: #Создаем задачу
                            scheduled.create_CheckTask_noFogetClose(worker_id, "free")

                
                # Настройка нужно ли спрашивать о переработке
                    try: #Пытаемся получить нужно ли проверять это
                        noFogetCloseElse = worker_perms["Conf_keep_other_timer"]
                    except: pass # Если не получилось ничего не делаем
                    else:
                        if noFogetCloseElse[0] == 1: #Создаем задачу
                            scheduled.create_CheckTask_noFogetClose(worker_id, "else")

def delete_messages_byTask(max_per_step):
    bd = select_task_byType_list("1:deleteMessage", how_many_items=max_per_step, orderBy="ASC")
    if bd:
        for task in bd:
            do_delete(task[5])
            delete_task_byId( task[0] )



async def do_task(max_per_step):
    # print("___DO TASK")

    # if True: #scheduled.markEveryDayTask(): 
    if scheduled.markEveryDayTask(): # Если не было сегодня ежедневного задания

        #Удаляем устаревшие записи
        delete_older_Day( scheduled.getOldDay( modMonth=-2 ) )
        #Удалить дни, на которые нет записей
        delete_Old_tasks( scheduled.getOldDay( modDay=-1 ) )
        delete_guests()

        #Удаляем пользователей, на которых нет записей (перенесено внутрь создания задач проверок)

        #Запускаем создание задач проверок
        user_checkTask_init()

        return

    """
    Типы задач: (task_text, for_who)
        По пользователям
            0:whyNotAtWork 1:+:{telegram_id}
            0:checkAtWork 1:+:{telegram_id}
        Системные
            1:deleteMessage -:=:message_id
            1:checkStartWork -:=:*
            1:everyDay_task -:=:*
    """

    # удаляем сообщения в очереди на удаление
    delete_messages_byTask(max_per_step)
    # проверяем время и если ночь, то завершаем все таймеры и начинаем их по-новой через час

    # обрабатываем опоздавших
    bd = select_task_byType_list("0:checkAtWork", how_many_items=max_per_step, orderBy="ASC") #Сначала открываем старые записи
    if bd: #((0:id 1:task_text 2:create_time 3:actual_time 4:remove_time 5:for_who),...)
        for task in bd:
            if task[3] < scheduled.getTime(): #Если уже человек должен был прийти
                level, symb, id = task[5].split(":")
                await late_needAsk(int(id), task[0])

            



    """
    Задачи создались.
    Теперь дело за малым - инициировать вопросы к каждой задаче

    Получаем список задач с конкретной целью (спросить, пришел ли вовремя)
        Запускаем функцию Уточнить
            Если вопрос пока не нужно задавать, то вовращаем "Нет"
            Если вопрос нужно задать, то возвращаем "Да"

            возврата не будет.
                Ф-я сама проверит, нужно ли выполнять задачу или нужно создать новую задачу или просто удалить текущую


            await timer_Why_Not_At_Work( id ) Conf_work_start

    """

        

        

                    





# #Нужно получить по названию права и иду пользователя параметр права




# """
# Делать постоянно:
#     1)Была ли ежедневная проверка?
#         Н: выполнить проверку и создать задачу, что она уже была
#         Д: Все хорошо, игнорируем ее
#     2)выполнять запланированные задачи
#     3)удалить устаревшие задачи
#     4)удалять сообщения поставленные на удаление 1:deleteMessage

# Делать 1 раз в день:
#     1)Нам нужно узнать кого конкретно сегодня нужно о чем-либо опрашивать

#     получаем список пользователей, которые не гости
#         получаем список прав пользователей
#             ищем там
#                 Есть ли запись о рабочих днях?         <---  Среди Conf_ найти Conf_work_days 
#                     Н:  нет рабочих дней - игнорируем
#                     Д:  Проверяем, рабочий ли это день
#                         Н: не рабочий день - игнорируем
#                         Д: Ставим задачу проверять все что нужно проверять в рабочие дни
    
#     2) Удалить устаревшие записи о днях
#     3) Удалить пользователей, о которых нет записей на день(ни одной)
#     4) Удалить устаревшие логи
#     5) Удалить устаревшие задачи

# Задачи для пользователей, которые работают в конкретный день:
#     Получить права пользователя и найти из них те, которые начинаются с Conf_

#         Conf_work_start  Строка "ЧЧ:ММ" или "-" если игнорировать
#             Если такая есть, то поставить задачу "Узнать, пришел ли человек"

#         Conf_need_echo настройка нужно ли отмечать присутствие раз в рабочий день (1)- да
#             Если такая есть, то поставить задачу "проверить за сутки, отмечался ли человек"

#         Conf_no_overheat настройка, нужно ли спрашивать о переработках
#             Если такая есть, то поставить задачу "проверять каждый час, не перерабатывает ли человек"
#                 Проверка на переработку зависит от Conf_work_lenght (сколько человек должен работать)

#         Conf_keep_work_timer  нужно ли проверять, не забыл ли человек выключить рабочий таймер
#             Если такая есть, то поставить задачу "Не забыл ли человек выключить таймер?"
#                 получает время работы и если таймер насчитал больше, чем рабочий день, спрашивать "Не забыли ли вы выключить таймер?" каждые 30минут

#         Conf_keep_free_timer нужно ли проверять, не забыл ли человек выключить таймер перерывал
#             Если такая есть, то поставить задачу "Не забыл ли человек выключить таймер?" и если таймер обеда насчитал более обеденого времени, то спрашивать

#         Conf_keep_other_timer  Нужно ли проверять, не забыл ли человек выключить Любой таймер
#             Если такая есть, получать список таймеров (кроме рабочего или перерывов)

# """






# """
# Делать постоянно:
#     1)Была ли ежедневная проверка?
#         Н: выполнить проверку и создать задачу, что она уже была
#         Д: Все хорошо, игнорируем ее
#     2)выполнять запланированные задачи
#     3)удалить устаревшие задачи

# Делать 1 раз в день:
#     1)Нам нужно узнать кого конкретно сегодня нужно о чем-либо опрашивать

#     получаем список пользователей, которые не гости
#         получаем список прав пользователей
#             ищем там
#                 Есть ли запись о рабочих днях?         <---  Среди Conf_ найти Conf_work_days 
#                     Н:  нет рабочих дней - игнорируем
#                     Д:  Проверяем, рабочий ли это день
#                         Н: не рабочий день - игнорируем
#                         Д: Ставим задачу проверять все что нужно проверять в рабочие дни
    
#     2) Удалить устаревшие записи о днях
#     3) Удалить пользователей, о которых нет записей на день(ни одной)
#     4) Удалить устаревшие логи
#     5) Удалить устаревшие задачи

# Задачи для пользователей, которые работают в конкретный день:
#     Получить права пользователя и найти из них те, которые начинаются с Conf_

#         Conf_work_start  Строка "ЧЧ:ММ" или "-" если игнорировать
#             Если такая есть, то поставить задачу "Узнать, пришел ли человек"

#         Conf_need_echo настройка нужно ли отмечать присутствие раз в рабочий день (1)- да
#             Если такая есть, то поставить задачу "проверить за сутки, отмечался ли человек"

#         Conf_no_overheat настройка, нужно ли спрашивать о переработках
#             Если такая есть, то поставить задачу "проверять каждый час, не перерабатывает ли человек"
#                 Проверка на переработку зависит от Conf_work_lenght (сколько человек должен работать)

#         Conf_keep_work_timer  нужно ли проверять, не забыл ли человек выключить рабочий таймер
#             Если такая есть, то поставить задачу "Не забыл ли человек выключить таймер?"
#                 получает время работы и если таймер насчитал больше, чем рабочий день, спрашивать "Не забыли ли вы выключить таймер?" каждые 30минут

#         Conf_keep_free_timer нужно ли проверять, не забыл ли человек выключить таймер перерывал
#             Если такая есть, то поставить задачу "Не забыл ли человек выключить таймер?" и если таймер обеда насчитал более обеденого времени, то спрашивать

#         Conf_keep_other_timer  Нужно ли проверять, не забыл ли человек выключить Любой таймер
#             Если такая есть, получать список таймеров (кроме рабочего или перерывов)

# """






#     # bd_task = select_task_byType_list("0:", orderBy="ASC") #Получаем задачи. Сначала - самые старые
#     # if bd_task:

#     #     MAXIMUM = 5 # сколько задач выбираются за один Тик бота
#     #     LEVEL_NOT_ASK = 2

#     #     tasksCount = len(bd_task)

#     #     for ind in range( tasksCount if tasksCount < MAXIMUM else MAXIMUM ):
#     #         text = bd_task[ind][1]
            
#     #         #Обрабатываем задачи, которые по поводу опозданий
#     #         if text == "0:whyNotAtWork": #Если записаная задача - спросить, почему не пришел


#     #             level, symb, id = bd_task[ind][5].split(":")


#     #             if int(level)>=LEVEL_NOT_ASK: #Если человек директор, то его странно допрашивать
#     #                 delete_task_byId( bd_task[ind][0] ) #Удаляем задачу
#     #                 continue

#     #             if sch.getTime() < bd_task[ind][3]: #Если задача не должна исполняться прямо сейчас пропускаем
#     #                 #print( "contin do_task()", sch.getTime(), bd_task[ind][3] )
#     #                 continue

#     #             else:
#     #                 #print( "not contin do_task()", sch.getTime(), bd_task[ind][3] )
#     #                 pass

#     #             delete_task_byId( bd_task[ind][0] ) #Удаляем задачу
#     #             await timer_Why_Not_At_Work( id )

#     #         #Обрабатываем задачи, которые по поводу переработок
